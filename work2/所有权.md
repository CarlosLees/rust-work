## 对所有权、不可变引用、可变引用这三者的规则或特性做一个集中的总结，写一个笔记列表。

### 所有权规则
所有权规则决定了堆内存上值的归属问题，一个值最好只有一个拥有者，因为所有权共享，势必会带来使用和释放上的不明确，走回`追踪式GC` 或者 `ARC` 的老路。
```rust
fn main() {
    let data = vec![1,2,3];
    let v = 1;
    if let Some(res) = find_v(data,v) {
        println!("{}", res);
    }
}

fn find_v(data: Vec<i32>,v:i32) -> Option<usize> {
    for (index,item) in data.iter().enumerate() {
        if *item == v {
            return Some(index)
        }
    }
    None
}
```
如果是别的编程语言，这个时候堆内存上的Vec就有了两个引用，一个在`main`函数内，另一个在`find_v`函数中，而且每把data传递一次，引用的个数就会增加一次。


Rust给出了自己的所有权规则:
```
1.一个值只能被一个一个变量拥有。

2.一个值同一时刻只能有一个所有者，所以变量赋值，参数传递，函数返回等行为，旧的所有者会把所有权转移给新的所有者。

3.当所有者离开其作用域，它拥有的值会被丢弃，内存得到释放。
```

#### Move和Copy
所有权规则，决定了值的归属问题，让堆上的数据不会被重复引用，但是对应栈上一些简单的数据，如果要避免所有权转移，还需要手动复制，带来了一定的麻烦。
针对这个问题，Rust同样提供了方案:

```
1.如果不希望所有权转移，除了Move语义之外，Rust提供了Copy语义。如果一个数据类型实现了Copy trait，那么它就会使用Copy语义，
在赋值和传参的时候，会自动按位拷贝。
2.如果不希望所有权转移，可以借用/引用数据。
```
一些实现了Copy trait的数据类型：
1.原生类型，函数，不可变引用和裸指针。
2.数组和元组，如果其内部的数据结构实现了Copy，那么它们也实现了trait。

#### 引用
本质上，引用是一个受控的指针，指向某一个特定的类型。
```
引用和指针的一些区别：
1.内存地址：指针存储的是内存地址，而引用是某个变量的别名，即引用和所引用的变量在内存中占用同一块空间。

2.空指针：指针可以指向空地址（NULL），表示未指向任何有效对象。而引用必须始终引用某个已存在的对象，因此不存在空引用。

3.内存管理：指针需要手动分配和释放内存，而引用则由编译器自动管理。

4.可变性：指针本身可以被重新赋值指向另一个对象，而引用始终指向同一对象，无法重新指向其他对象。
```
在Rust中，没有传引用的概念，所有的参数传递都是传值，Rust的引用实现了Copy trait，所以按照Copy语义，引用会复制一份交给要
调用的函数。对这个函数来说，它并不拥有这个数据本身，数据的所有权还是在原来的拥有者那里。

##### 引用的生命周期及其约束
引用不能超过值的生存期。
堆内存的生命周期不具备任意长短的灵活性，因为堆上内存的生死，跟栈上的所有者绑定，而栈上内存的生命期，又跟站的生命期有关，
搜易只需要关心调用栈的生命周期即可。

#### 可变引用
在没有引入可变借用之前，因为一个值同一时刻只有一个所有者，所以如果要修改这个值，只能通过唯一的所有者进行。
但是，如果允许借用改变值本身，会带来新的问题。

1.存在多个可变引用。
```rust
fn main() {
    let mut data = vec![1,2,3];
    for item in data.iter_mut() { 
        data.push(*item + 1); 
    }
}
```
在遍历`data`的时候，同时往`data`里添加数据,会造成程序的崩溃。所以在同一个作用域下存在多个可变引用是不安全的。

2.存在多个只读引用和一个可变引用。
```rust
fn main() {
    let mut data = vec![1, 2, 3];
    let data1 = vec![&data[0]];
    println!("data[0]: {:p}", &data[0]);
    
    for i in 0..10000 {
        data.push(i);
    }
    println!("data[0]: {:p}", &data[0]);

    data[0]: 0x600002950030
    data[0]: 0x7fd820800000
}
```
如果继续添加元素，堆上的数据预留的空间不够了，就会重新分配一片足够大的内存，把之前的值拷过来，然后释放旧的内存。
这样就会让 data1 中保存的 &data[0] 引用失效，导致内存安全问题。

为了保证内存安全，Rust 对可变引用的使用也做了严格的约束：
```
1、在一个作用域内，仅允许一个活跃的可变引用。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。
2、在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。
```

### 结尾
1.一个值在同一时刻只有一个所有者。当所有者离开了作用域，其拥有的值就会被丢弃。赋值或者传参会导致值Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。

2.如果值实现了Copy trait，那么赋值或传参就会使用Copy语义，相应的值会被按位拷贝，产生新的值。

3.一个值可有有多个只读引用。

4.一个值可以有唯一一个活跃的可变引用，可变引用和只读引用是互斥的关系，就像并发下数据的读写互斥那样。

5.引用的生命周期不能超过值的生命周期，值的生命周期不能超过调用栈的生命周期。

```rust
fn main() { 
	let mut arr = vec![1,2,3]; 
	let last = arr.last(); 
	println!("last: {:?}", last); 
	arr.push(4);
}
```
编译器自己做了优化, 添加了一些生命周期标志, 使得不可变引用的生命周期在打印调用完之后就提前结束了, 之后再使用可变引用就没问题了